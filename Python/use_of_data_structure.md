# 23/01/26 데이터 구조 활용

> **데이터 구조란?**

- 여러 데이터를 효과적으로 사용, 관리하기 위한 구조(많이 사용해보니까, 비슷한 구조가 있음
- 파이썬에는 대표적으로 List, Tuple, Dict, Set 등의 데이터 구조가 있음

</br>

> **자료구조**

- 컴퓨터 공학에서는 ‘자료구조’라고 함
- 각 데이터의 효율적인 저장, 관리를 위한 구조를 나눠 놓은 것

</br>

# 순서가 없는 데이터 구조

### 셋(set)

> **셋(Set)**

- Set이란 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
  - 데이터의 중복을 허용하지 않기 때문에 중복되는 원소가 있다면 하나만 저장
  - 순서가 없기 때문에 인덱스를 이용한 접근 불가능
- 수학에서의 집합을 표현한 컨테이너
  - 집합 연산이 가능(여집합을 표현하는 연산자는 별도로 존재 X)
  - 중복된 값이 존재하지 않음
- 담고 있는 요소를 삽입 변경, 삭제 가능 → 가변 자료형 (mutable)

</br>

> **셋 메서드 (s는 셋)**

| 문법                       | 설명                                                 |
| ------------------------ | -------------------------------------------------- |
| s.copy()                 | 셋의 얕은 복사본을 반환                                      |
| s.add(x)                 | 항목 x가 셋 s에 없다면 추가                                  |
| s.pop()                  | 셋 s에서 랜덤하게 항목을 반환하고, 해당 항목을 제거                     |
| set이 비어 있을 경우, KeyError  |                                                    |
| s.remove(x)              | 항목 x를 셋 s에서 삭제                                     |
| 항목이 존재하지 않을 경우, KeyError |                                                    |
| s.discard(x)             | 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제                   |
| s.update(t)              | 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가                     |
| s.clear()                | 모든 항목을 제거                                          |
| s.isdisjoint(t)          | 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우, True 반환(서로소) |
| s.issubset(t)            | 셋 s가 셋 t의 하위 셋인 경우, True 반환                        |
| s.issuperset(t)          | 셋 s가 셋 t의 상위 셋인 경우, True 반환                        |

 </br>

### 딕셔너리(Dictionary)

> **딕셔너리의 정의**

- 키 - 값(key-value)쌍으로 이뤄진 자료형(3.7부터는 ordered, 이하 버전은 unordered)
- Dictionary의 키(key)
  - key는 변경 불가능한 데이터(immutable)만 활용 가능
    - string, integer, float, boolean, tuple, range
- 각 키의 값(values)
  - 어떠한 형태든 관계없음

| 문법                | 설명                                                                    |
| ----------------- | --------------------------------------------------------------------- |
| d.clear()         | 모든 항목을 제거                                                             |
| d.copy()          | 딕셔너리 d의 얕은 복사본을 반환                                                    |
| d.keys()          | 딕셔너리 d의 모든 키를 담은 뷰를 반환                                                |
| d.values()        | 딕셔너리 d의 모든 값을 담은 뷰를 반환                                                |
| d.items()         | 딕셔너리 d의 모든 키 - 값의 쌍을 담은 뷰를 반환                                         |
| d.get(k)          | 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 None을 반환                            |
| d.get(k,v)        | 키 k의 값을 반환하는데, 키 k 가 딕셔너리 d에 없을 경우 v을 반환                              |
| d.pop(k)          | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 KeyError를 발생 |
| d.pop(k, v)       | 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제하는데, 키 k가 딕셔너리 d에 없을 경우 v를 반환        |
| d.update([other]) | 딕셔너리 d의 값을 매핑하여 업데이트                                                  |

 </br>

# 얕은 복사와 깊은 복사

### 얕은 복사와 깊은 복사(Shallow Copy & Deep Copy)

> **자료형과 메모리**

- 데이터 10을 컴퓨터가 기억하는 과정
  1. 10을 저장할 공간을 메모리에 만들고
  2. 저장할 공간에 대한 주소를 할당받는다.
  3. 할당 받은 주소를 기억했다가
  4. 10이라는 데이터를 해당 주소로 찾아가서 저장한다
  5. 이후에 10이 필요해지면 해당 주소로 가서 읽어온다.

</br>

> **기존 변수 사용 과정에서의 문제점?**

- 하나의 기억에, 하나의 주소가 필요 == 100개 저장하려면 100개 필요함
- 여러 기억을 하나의 주소로 찾아갈 수 있도록 할 수 없나?
- 연속적인 공간에 데이터가 저장되도록 함 == 맨 처음 기억의 **주소**만 가지고 있으면 된다.

</br>

> **얕은 복사(Shallow Copy)**

- 서울_1반_학생들_점수표
- 우리반_점수표 = 서울_1반_학생들_점수표
- = 을 사용한 복사

</br>

> **깊은 복사(Deep Copy)**

- 데이터를 그대로 다른 주소에 복사하고 거기에 변수를 가리키도록 함

</br>

> **복사 방법**

- 할당(assignment)
- 얕은 복사(Shallow copy)
- 깊은 복사(Deep copy)

</br>

> **할당(assignment)**

- 대입 연산자(=)
  - 리스트 복사 확인하기
  - 대입 연산자(=)를 통한 복사는 해당 객체에 대한 객체 참조를 복사
  - 해당 주소의 일부 값을 변경하는 경우 이를 참조하는 모든 변수에 영향

</br>

> **얕은 복사(Shallow Copy)**

- Slice 연산자를 활용하여 같은 원소를 가진 리스트지만 연산된 결과를 복사(다른 주소) → 깊은 복사 아닌가?
  
  - 예) 리스트안의 리스트 : 복사하는 리스트의 원소가 주소를 참조함. 안의 리스트 변경시 함께 변경됨
  
  ```python
  a = [1, 2, ['a', 'b']]
  b = a[:]
  print(a, b) # [1, 2, ['a', 'b']] [1, 2, ['a', 'b']] 
  b[2][0] = 0
  print(a, b) # [1, 2, ['0', 'b']] [1, 2, ['0', 'b']] 
  ```

</br>

> **깊은 복사(Deep Copy)**

- 리스트 복사 확인하기

```python
import copy

a = [1, 2, ['a', 'b']]
b = copy.deepcopy(a)
print(a, b) # [1, 2, ['a', 'b']] [1, 2, ['a', 'b']] 
b[2][0] = 0
print(a, b) # [1, 2, ['a', 'b']] [1, 2, ['0', 'b']] 
```

</br>

> **결론**

- 리스트를 복사하고 싶다는 욕망이 든다면 무조건 print 찍어볼 것! (혹은 디버깅 툴로 리스트 변화를 확인할 것)
- 그냥 모두 copy.deepcopy쓰면 되는거 아닌가요?
  - 컴퓨터의 메모리 용량 증가






