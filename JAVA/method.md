# 메서드

> 메서드의 정의와 필요성

- 메서드란?
  - 현실의 객체가 하는 동작을 프로그래밍 화
  - 어떤 작업을 수행하는 명령문의 집합
- 메서드를 작성하는 이유
  - 반복적으로 사용되는 코드의 중복 방지
    - DRY : Don’t Repeat Yourself
    - WET : We Enjoy Typing or Write Everything Twice
  - 코드의 양을 줄일 수 있고 유지 보수가 용이함

<br>

> **메서드의 정의와 필요성**

```java
class Person {
    String name;
    int age = 0;
}
```

- 메서드를 사용하지 않았을 경우

```java
Person p = new Person();
System.out.println(p.name+":"+p.age);
Person p2 = new Person();
System.out.println(p2.name+":"+p2.age);
```

- 메서드를 사용했을 경우

```java
Person p = new Person();
Person p2 = new Person();
p.printInfo();
p2.printInfo();
```

- 메서드의 작성 방법

```java
제한자 리턴_타입 메서드이름(타입 변수_명, 타입 변수_명)
{
    // do something
}
```

- 어떤 값을 입력 받아서 → 파라미터(생략 가능)
- 작업을 진행하고 → 실행 문장
- 결과를 돌려주는 역할 → 리턴 값(생략 가능)

<br>

> **Variable arguments**

- 메서드 선언 시 몇 개의 인자가 들어올 지 예상할 수 없을 경우(또는 가변적)
  - 배열 타입을 선언할 수 있으나 → 메서드 호출 전 배열을 생성, 초기화 해야 하는 번거로움
  - …을 이용해 파라미터를 선언하면서 호출 시 넘겨준 값의 개수에 따라 자동으로 배열 생성 및 초기화

```java
public static void main(String[] args) {
    VariableTest vt = new VariableTest();
    vt.variableArgs(1, 2, 3);
    vt.variableArgs(1, 2, 3, 4, 5);
    vt.variableArgs(1, 2);
}
public void variableArgs(int... params){
    int sum = 0;
    for(int i : params) {
        sum += i;
    }
    System.out.println(sum);
}
```

<br>

> **구현부**

- 구현부는 중괄호 내에서 처리해야 하는 내용 즉 비즈니스 로직 작성
- 마지막에는 선언된 리턴 타입에 해당하는 값을 return 문장과 함께 반환해야 함
  - 값 반환시에는 묵시적 형 변환 적용
  - 리턴 타입이 void여서 반환할 값이 없을 경우 return 문장 생략 가능
  - 메서드 수행 도중 return 문장을 만나거나 마지막 문장을 수행하는 경우 메서드는 종료
    - 조건문을 이용해서 return 할 경우 모든 조건에서 return 필요

<br>

> **메서드 호출**

- 메서드를 호출할 때는 메서드의 선언부에 맞춰 호출해야 함.
  
  - 메서드 이름 : 반드시 동일
  - 파라미터 : 선언된 파라미터의 개수는 반드시 동일, 타입은 promotion 적용 가능

- 메서드 접근
  
  - 멤버 변수와 마찬가지로 static 또는 non static 상태를 구분해서 호출
  
  |       | 비고     | static member | non static member(instance member) |
  | ----- | ------ | ------------- | ---------------------------------- |
  |       | 소속     | 클래스           | 객체                                 |
  | 접근 방법 | 같은 클래스 | 바로 호출         | 바로 호출                              |
  |       | 다른 클래스 | 클래스_이름.멤버_이름  | 객체_이름.멤버_이름                        |
  
  - 가장 중요한 것은 호출하려는 멤버가 메모리에 있는가?
    - 메모리에 있으면 호출 가능
    - 메모리에 없으면 호출 불가 - 먼저 메모리에 로딩 후 사용해야 함

<br>

> **class 멤버와 instance 멤버간의 참조와 호출**

- 가장 중요한 것은 메모리에 있는가?
  - 메모리에 있으면 호출 가능
  - 메모리에 없으면 호출 불가
- static member → 언제나 메모리에 있음
  - 클래스 로딩 시 자동 등록
- instance member → 객체 생성 전에는 메모리에 없음
  - 객체 생성 시 모든 일반 멤버들은 메모리에 생성
  - 객체 즉 레퍼런스를 통해서 접근

<br>

> 메서드 호출 스택

- 스택(stack)
  - First in Last out의 구조
- 메서드 호출 스택
  - 각각의 메서드 호출 시 마다 메서드 동작을 위한 메모리 상자를 하나씩 할당
    - 상자 내부에 메서드를 위한 파라미터 변수 등 로컬 변수 구성
  - A메서드에서 새로운 메서드 B 호출 시 B 실행을 위한 메모리 상자를 쌓음
    - 언제나 맨 위에 있는 메모리 상자(B)만 활성화
    - 이때 A메서드는 동작이 끝나지 않고 잠시 정지된 상태
    - B가 리턴하게 되면 B를 위한 상자가 제거되며 메모리 반납
    - 비로서 A가 최 상위가 돼서 다시 동작 재개

<br>

> **기본형 변수와 참조형 변수**

- 메서드 호출 시 파라미터로 입력된 **값을 복사**해서 전달
- Java는 call by value!! Value의 정체는?

<br>

> **메서드 오버로딩**

- overloading : 동일한 기능을 수행하는 메서드의 추가 작성
  - 일반적으로 메서드 이름은 기능별로 의미 있게 정함
  - 동일한 기능을 여러 형태로 정의해야 한다면?
  - eat vs eatUsingChopsticks, eatUsingFork, eatUsingSpoon..?
    - 입으로 이동하는 부분까지만 다르고 그 이후의 동작은?
- 메서드 오버로딩의 장점
  - 기억해야 할 메서드가 감소하고 중복 코드에 대한 효율적 관리 가능

<br>

> **메서드 오버로딩의 방법**

- 메서드 이름은 동일
- 파라미터의 개수와 또는 순서, 타입이 달라야 할 것
  - 파라미터가 같으면 중복 선언 요류
- 리턴 타입은 의미 없음

<br>

> **생성자**

- 객체를 생성할 때 호출하는 메서드 비슷한 것
  - new 키워드와 함께 호출하는 것
  - 일반 멤버 변수의 초기화난 객체 생성 시 실행돼야 하는 작업 정리
- 작성 규칙
  - 메서드와 비슷하나 리턴 타입이 없고 이름은 클래스 이름과 동

```java
제한자 클래스_명(타입 변수_명, 타입 변수_명)
{
    // 멤버 변수 초기화 작업
}
```

<br>

> **생성자의 종류**

- 기본 생성자(default constructor)
  - 그 동안 예제에서는 생성자를 작성하지 않았음
    - 기본 생성자의 형태는 파라미터가 없고 구현부가 비어있는 형태
    - 생성자 코드가 없으면 컴파일러가 기본 생성자 제공
- 파라미터가 있는 생성자
  - 생성자의 목적이 일반 멤버 변수의 초기화 →생성자 호출 시 값을 넘겨줘서 초기화
  - 주의! 파라미터가 있는 생성자를 만들면 기본 생성자는 추가되지 않는다

<br>

> **this()**

- 참조 변수로써 객체 자신을 가리킴
  - 참조변수를 통해 객체의 멤버에 접근했던 것처럼 this를 이용해 자신의 멤버에 접근 가능
- 용도
  - 로컬 변수와 멤버 변수의 이름이 동일할 경우 멤버 변수임을 명시적으로 나타냄
  - 명시적으로 멤버임을 나타낼 경우 사용
- this는 객체에 대한 참조
  - 따라서 static 역역에서 this 사용 불가
- 메서드와 마찬가지로 생성자도 오버로딩 가능
  - 객체 생성 시 필요한 멤버 변수만 초기화 진행 → 생성자 별 코드의 중복 발생
  - 한 생성자에서 다른 생성자를 호출할 때 사용
- 반드시 첫 줄에서만 호출이 가능
