# 다형성

> **다형성(Polymorphism : Java Is A PIE)**

- 하나의 객체가 많은 형(타입)을 가질 수 있는 성질
- 다형성의 정의
  - 상속 관계에 있을 때 조상 클래스의 타입으로 자식 클래스 객체를 레퍼런스 할 수 있다.
- 배열의 특징 - 같은 타입의 데이터 묶음으로 다룬다
  - 다형성으로 다른 타입의 데이터(Person, SpiderMan)를 하나의 배열로 관리
- Object는 모든 클래스의 조상
  - Object의 배열은 어떤 타입의 객체라도 다 저장할 수 있음
- 자바의 자료 구조를 간단하게 처리할 수 있음
  - 이와 같은 특성을 이용하여 Collection API가 등장하게 됨
- 메서드가 호출되기 위해서는 메서드 이름과 파라미터가 맞아야 하는데
  - 조상을 파라미터로 처리한다면 객체의 ㄴ타입에 따라 메서드를 만들 필요가 없어진다

<br>

> **다형성과 참조형 객체의 형 변환**

- 메모리에 있느 것과 사용할 수 있는 것의 차이
  - 메모리에 있더라도 참조하는 변수의 타입에 따라 접근할 수 있는 내용이 제한됨
- 작은 집(child)에서 큰 집(super)으로 → 묵시적 케스팅
  - 자손 타입의 객체를 조상 타입으로 참조 : 형변환 생략 가능
    - 왜냐면 조상의 모든 내용이 자식에 있기 때문에 걱정할 필요가 없다
- 큰 집(super)에서 작은 집(child)으로 → 명시적 케스팅
  - 조상 타입을 자손 타입으로 참조 : 형변환 생략 불가
- 조상을 무작정 자손으로 바꿀 수는 없다
  - instanceof 연산자
    - 실제 메모리에 있는 객체가 특정 클래스 타입인지 boolean으로 리턴

<br>

> **참조 변수의 레벨에 따른 객체의 멤버 연결**

- 정적 바인딩(static binding)
  - 컴파일 단계에서 **참조 변수의 타입에 따라** 연결이 달라짐
  - 상속 관계에서 객체의 **멤버 변수(static/instance)가 중복**될 때 또는 static method
- 동적 바인딩(dynamic binding)
  - 다형성을 이용해서 메서드 호출이 발생할 때 runtime에 메모리의 실제 객체의 타입으로 결정
  - 상속 관계에서 객체의 **instance method가 재정의** 되었을 때 마지막 재정의 된 **자식 클래스의 메서드가 호출**됨
    - 최대한 메모리에 생성된 실제 객체에 최적환 된 메서드가 동작한다.

|              | 정적 바인딩   | 동적 바인딩               |
| ------------ | -------- | -------------------- |
| 수행 속도        | 상대적으로 빠름 | 상대적으로 느림             |
| 메모리 공간 활용 효율 | 상대적으로 높음 | 상대적으로 낮음             |
| 객체지향적        |          | 다형성으로 효율적인 코드 재사용 가능 |

- 상위로 올라갈수록 활용도도 높아짐
  - 하지만 코드의 복잡성도 함께 증가
- Java API처럼 공통 기능인 경우 Object를 파라미터로 쓰겠지만
  - 많은 경우 비지니스 로직상 최상위 객체 사용 권장
